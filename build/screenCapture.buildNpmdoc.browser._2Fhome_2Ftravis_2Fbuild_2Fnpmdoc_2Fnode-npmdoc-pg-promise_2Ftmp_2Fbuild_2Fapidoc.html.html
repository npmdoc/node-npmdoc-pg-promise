<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/vitaly-t/pg-promise">pg-promise (v5.6.4)</a>
</h1>
<h4>Promises interface for PostgreSQL</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise">module pg-promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.ParameterizedQuery">
            function <span class="apidocSignatureSpan">pg-promise.</span>ParameterizedQuery
            <span class="apidocSignatureSpan">(text, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.PreparedStatement">
            function <span class="apidocSignatureSpan">pg-promise.</span>PreparedStatement
            <span class="apidocSignatureSpan">(name, text, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.PromiseAdapter">
            function <span class="apidocSignatureSpan">pg-promise.</span>PromiseAdapter
            <span class="apidocSignatureSpan">(create, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.QueryFile">
            function <span class="apidocSignatureSpan">pg-promise.</span>QueryFile
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.ParameterizedQueryError">
            function <span class="apidocSignatureSpan">pg-promise.</span>errors.ParameterizedQueryError
            <span class="apidocSignatureSpan">(error, ps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.PreparedStatementError">
            function <span class="apidocSignatureSpan">pg-promise.</span>errors.PreparedStatementError
            <span class="apidocSignatureSpan">(error, ps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryFileError">
            function <span class="apidocSignatureSpan">pg-promise.</span>errors.QueryFileError
            <span class="apidocSignatureSpan">(error, qf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryResultError">
            function <span class="apidocSignatureSpan">pg-promise.</span>errors.QueryResultError
            <span class="apidocSignatureSpan">(code, result, query, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify">
            function <span class="apidocSignatureSpan">pg-promise.</span>minify
            <span class="apidocSignatureSpan">(sql, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify.SQLParsingError">
            function <span class="apidocSignatureSpan">pg-promise.</span>minify.SQLParsingError
            <span class="apidocSignatureSpan">(code, position)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>ParameterizedQuery.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>PreparedStatement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>QueryFile.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>array</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>as</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>errors.ParameterizedQueryError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>errors.PreparedStatementError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>errors.QueryFileError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>errors.QueryResultError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>formatting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>minify.SQLParsingError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>queryResult</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>special</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>txMode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.ParameterizedQuery">module pg-promise.ParameterizedQuery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.ParameterizedQuery.ParameterizedQuery">
            function <span class="apidocSignatureSpan">pg-promise.</span>ParameterizedQuery
            <span class="apidocSignatureSpan">(text, values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.ParameterizedQuery.prototype">module pg-promise.ParameterizedQuery.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.ParameterizedQuery.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.ParameterizedQuery.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.PreparedStatement">module pg-promise.PreparedStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.PreparedStatement.PreparedStatement">
            function <span class="apidocSignatureSpan">pg-promise.</span>PreparedStatement
            <span class="apidocSignatureSpan">(name, text, values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.PreparedStatement.prototype">module pg-promise.PreparedStatement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.PreparedStatement.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.PreparedStatement.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.QueryFile">module pg-promise.QueryFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.QueryFile.QueryFile">
            function <span class="apidocSignatureSpan">pg-promise.</span>QueryFile
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.QueryFile.prototype">module pg-promise.QueryFile.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.QueryFile.prototype.inspect">
            function <span class="apidocSignatureSpan">pg-promise.QueryFile.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.QueryFile.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.QueryFile.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.array">module pg-promise.array</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.array.countIf">
            function <span class="apidocSignatureSpan">pg-promise.array.</span>countIf
            <span class="apidocSignatureSpan">(arr, cb, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.array.filter">
            function <span class="apidocSignatureSpan">pg-promise.array.</span>filter
            <span class="apidocSignatureSpan">(arr, cb, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.array.forEach">
            function <span class="apidocSignatureSpan">pg-promise.array.</span>forEach
            <span class="apidocSignatureSpan">(arr, cb, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.array.map">
            function <span class="apidocSignatureSpan">pg-promise.array.</span>map
            <span class="apidocSignatureSpan">(arr, cb, obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.as">module pg-promise.as</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.array">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>array
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.bool">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>bool
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.buffer">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>buffer
            <span class="apidocSignatureSpan">(obj, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.csv">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>csv
            <span class="apidocSignatureSpan">(resolveFunc(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.date">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>date
            <span class="apidocSignatureSpan">(d, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.format">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>format
            <span class="apidocSignatureSpan">(query, values, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.func">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>func
            <span class="apidocSignatureSpan">(func, raw, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.json">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>json
            <span class="apidocSignatureSpan">(obj, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.name">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>name
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.number">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>number
            <span class="apidocSignatureSpan">(num)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.text">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>text
            <span class="apidocSignatureSpan">(value, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.as.value">
            function <span class="apidocSignatureSpan">pg-promise.as.</span>value
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors">module pg-promise.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.ParameterizedQueryError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>ParameterizedQueryError
            <span class="apidocSignatureSpan">(error, ps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.PreparedStatementError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>PreparedStatementError
            <span class="apidocSignatureSpan">(error, ps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryFileError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryFileError
            <span class="apidocSignatureSpan">(error, qf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryResultError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryResultError
            <span class="apidocSignatureSpan">(code, result, query, values)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.errors.</span>queryResultErrorCode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.ParameterizedQueryError">module pg-promise.errors.ParameterizedQueryError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.ParameterizedQueryError.ParameterizedQueryError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>ParameterizedQueryError
            <span class="apidocSignatureSpan">(error, ps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.ParameterizedQueryError.prototype">module pg-promise.errors.ParameterizedQueryError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.ParameterizedQueryError.prototype.inspect">
            function <span class="apidocSignatureSpan">pg-promise.errors.ParameterizedQueryError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.ParameterizedQueryError.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.errors.ParameterizedQueryError.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.PreparedStatementError">module pg-promise.errors.PreparedStatementError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.PreparedStatementError.PreparedStatementError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>PreparedStatementError
            <span class="apidocSignatureSpan">(error, ps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.PreparedStatementError.prototype">module pg-promise.errors.PreparedStatementError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.PreparedStatementError.prototype.inspect">
            function <span class="apidocSignatureSpan">pg-promise.errors.PreparedStatementError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.PreparedStatementError.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.errors.PreparedStatementError.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.QueryFileError">module pg-promise.errors.QueryFileError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryFileError.QueryFileError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryFileError
            <span class="apidocSignatureSpan">(error, qf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.QueryFileError.prototype">module pg-promise.errors.QueryFileError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryFileError.prototype.inspect">
            function <span class="apidocSignatureSpan">pg-promise.errors.QueryFileError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryFileError.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.errors.QueryFileError.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.QueryResultError">module pg-promise.errors.QueryResultError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryResultError.QueryResultError">
            function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryResultError
            <span class="apidocSignatureSpan">(code, result, query, values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.errors.QueryResultError.prototype">module pg-promise.errors.QueryResultError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryResultError.prototype.inspect">
            function <span class="apidocSignatureSpan">pg-promise.errors.QueryResultError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.errors.QueryResultError.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.errors.QueryResultError.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.events">module pg-promise.events</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.connect">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>connect
            <span class="apidocSignatureSpan">(ctx, client, isFresh)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.disconnect">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>disconnect
            <span class="apidocSignatureSpan">(ctx, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.error">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>error
            <span class="apidocSignatureSpan">(options, err, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.extend">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>extend
            <span class="apidocSignatureSpan">(options, obj, dc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.query">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>query
            <span class="apidocSignatureSpan">(options, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.receive">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>receive
            <span class="apidocSignatureSpan">(options, data, result, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.task">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>task
            <span class="apidocSignatureSpan">(options, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.transact">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>transact
            <span class="apidocSignatureSpan">(options, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.events.unexpected">
            function <span class="apidocSignatureSpan">pg-promise.events.</span>unexpected
            <span class="apidocSignatureSpan">(event, e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.formatting">module pg-promise.formatting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.formatting.formatFunction">
            function <span class="apidocSignatureSpan">pg-promise.formatting.</span>formatFunction
            <span class="apidocSignatureSpan">(funcName, values, capSQL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.formatting.formatQuery">
            function <span class="apidocSignatureSpan">pg-promise.formatting.</span>formatQuery
            <span class="apidocSignatureSpan">(query, values, raw, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.formatting.</span>as</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.minify">module pg-promise.minify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify.minify">
            function <span class="apidocSignatureSpan">pg-promise.</span>minify
            <span class="apidocSignatureSpan">(sql, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify.SQLParsingError">
            function <span class="apidocSignatureSpan">pg-promise.minify.</span>SQLParsingError
            <span class="apidocSignatureSpan">(code, position)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.minify.</span>parsingErrorCode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.minify.SQLParsingError">module pg-promise.minify.SQLParsingError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify.SQLParsingError.SQLParsingError">
            function <span class="apidocSignatureSpan">pg-promise.minify.</span>SQLParsingError
            <span class="apidocSignatureSpan">(code, position)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.minify.SQLParsingError.prototype">module pg-promise.minify.SQLParsingError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify.SQLParsingError.prototype.inspect">
            function <span class="apidocSignatureSpan">pg-promise.minify.SQLParsingError.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.minify.SQLParsingError.prototype.toString">
            function <span class="apidocSignatureSpan">pg-promise.minify.SQLParsingError.prototype.</span>toString
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.special">module pg-promise.special</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.special.SpecialQuery">
            function <span class="apidocSignatureSpan">pg-promise.special.</span>SpecialQuery
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.special.</span>cache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.txMode">module pg-promise.txMode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.txMode.TransactionMode">
            function <span class="apidocSignatureSpan">pg-promise.txMode.</span>TransactionMode
            <span class="apidocSignatureSpan">(tiLevel, readOnly, deferrable)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pg-promise.txMode.</span>isolationLevel</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pg-promise.utils">module pg-promise.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.utils.buildSqlModule">
            function <span class="apidocSignatureSpan">pg-promise.utils.</span>buildSqlModule
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.utils.camelize">
            function <span class="apidocSignatureSpan">pg-promise.utils.</span>camelize
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.utils.camelizeVar">
            function <span class="apidocSignatureSpan">pg-promise.utils.</span>camelizeVar
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.utils.enumSql">
            function <span class="apidocSignatureSpan">pg-promise.utils.</span>enumSql
            <span class="apidocSignatureSpan">(dir, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pg-promise.utils.objectToCode">
            function <span class="apidocSignatureSpan">pg-promise.utils.</span>objectToCode
            <span class="apidocSignatureSpan">(obj, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise" id="apidoc.module.pg-promise">module pg-promise</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.ParameterizedQuery" id="apidoc.element.pg-promise.ParameterizedQuery">
        function <span class="apidocSignatureSpan">pg-promise.</span>ParameterizedQuery
        <span class="apidocSignatureSpan">(text, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParameterizedQuery(text, values) {
    if (!(this instanceof ParameterizedQuery)) {
        return new ParameterizedQuery(text, values);
    }

    var currentError, PQ = {}, changed = true, state = {
        text: text,
        binary: undefined,
        rowMode: undefined
    };

    function setValues(v) {
        if (Array.isArray(v)) {
            if (v.length) {
                PQ.values = v;
            } else {
                delete PQ.values;
            }
        } else {
            if ($npm.utils.isNull(v)) {
                delete PQ.values;
            } else {
                PQ.values = [v];
            }
        }
    }

    setValues(values);

    /**
     * @name ParameterizedQuery#text
     * @type {string|QueryFile}
     * @description
     * A non-empty query string or a {@link QueryFile} object.
     */
    Object.defineProperty(this, 'text', {
        get: () =&gt; state.text,
        set: value =&gt; {
            if (value !== state.text) {
                state.text = value;
                changed = true;
            }
        }
    });

    /**
     * @name ParameterizedQuery#values
     * @type {array}
     * @description
     * Query formatting parameters, depending on the type:
     *
     * - `null` / `undefined` means the query has no formatting parameters
     * - `Array` - it is an array of formatting parameters
     * - None of the above, means it is a single formatting value, which
     *   is then automatically wrapped into an array
     */
    Object.defineProperty(this, 'values', {
        get: () =&gt; PQ.values,
        set: value =&gt; {
            setValues(value);
        }
    });

    /**
     * @name ParameterizedQuery#binary
     * @type {boolean}
     * @default undefined
     * @description
     * Activates binary result mode. The default is the text mode.
     *
     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}
     */
    Object.defineProperty(this, 'binary', {
        get: () =&gt; state.binary,
        set: value =&gt; {
            if (value !== state.binary) {
                state.binary = value;
                changed = true;
            }
        }
    });

    /**
     * @name ParameterizedQuery#rowMode
     * @type {string}
     * @default undefined
     * @description
     * Changes the way data arrives to the client, with only one value supported by $[pg]:
     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.
     *    By default, rows arrive as objects.
     */
    Object.defineProperty(this, 'rowMode', {
        get: () =&gt; state.rowMode,
        set: value =&gt; {
            if (value !== state.rowMode) {
                state.rowMode = value;
                changed = true;
            }
        }
    });

    /**
     * @name ParameterizedQuery#error
     * @type {errors.ParameterizedQueryError}
     * @default undefined
     * @readonly
     * @description
     * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise,
it is `undefined`.
     *
     * This property is primarily for internal use by the library.
     */
    Object.defineProperty(this, 'error', {
        get: () =&gt; currentError
    });

    if ($npm.utils.isObject(text, ['text'])) {
        state.text = text.text;
        state.binary = text.binary;
        state.rowMode = text.rowMode;
        setValues(text.values);
    }

    /**
     * @method ParameterizedQuery.parse
     * @description
     * Parses the current object and returns a simple `{text, values}`, if successful,
     * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.
     *
     * This method is primarily for internal use by the library.
     *
     * @returns {{text, values}|errors.ParameterizedQueryError}
     */
    this.parse = () =&gt; {

        var qf = state.text instanceof $npm.QueryFile ? s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.PreparedStatement" id="apidoc.element.pg-promise.PreparedStatement">
        function <span class="apidocSignatureSpan">pg-promise.</span>PreparedStatement
        <span class="apidocSignatureSpan">(name, text, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PreparedStatement(name, text, values) {
    if (!(this instanceof PreparedStatement)) {
        return new PreparedStatement(name, text, values);
    }

    var currentError, PS = {}, changed = true, state = {
        name: name,
        text: text,
        binary: undefined,
        rowMode: undefined,
        rows: undefined
    };

    function setValues(v) {
        if (Array.isArray(v)) {
            if (v.length) {
                PS.values = v;
            } else {
                delete PS.values;
            }
        } else {
            if ($npm.utils.isNull(v)) {
                delete PS.values;
            } else {
                PS.values = [v];
            }
        }
    }

    setValues(values);

    /**
     * @name PreparedStatement#name
     * @type {string}
     * @description
     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is
     * subsequently used to execute or deallocate a previously prepared statement.
     */
    Object.defineProperty(this, 'name', {
        get: () =&gt; state.name,
        set: value =&gt; {
            if (value !== state.name) {
                state.name = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#text
     * @type {string|QueryFile}
     * @description
     * A non-empty query string or a {@link QueryFile} object.
     *
     * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries
     * for Prepared Statements are cached, with {@link PreparedStatement#name name} being the cache key.
     */
    Object.defineProperty(this, 'text', {
        get: () =&gt; state.text,
        set: value =&gt; {
            if (value !== state.text) {
                state.text = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#values
     * @type {array}
     * @description
     * Query formatting parameters, depending on the type:
     *
     * - `null` / `undefined` means the query has no formatting parameters
     * - `Array` - it is an array of formatting parameters
     * - None of the above, means it is a single formatting value, which
     *   is then automatically wrapped into an array
     */
    Object.defineProperty(this, 'values', {
        get: () =&gt; PS.values,
        set: value =&gt; {
            setValues(value);
        }
    });

    /**
     * @name PreparedStatement#binary
     * @type {boolean}
     * @default undefined
     * @description
     * Activates binary result mode. The default is the text mode.
     *
     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}
     */
    Object.defineProperty(this, 'binary', {
        get: () =&gt; state.binary,
        set: value =&gt; {
            if (value !== state.binary) {
                state.binary = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#rowMode
     * @type {string}
     * @default undefined
     * @description
     * Changes the way data arrives to the client, with only one value supported by $[pg]:
     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.
     *    By default, rows arrive as objects.
     */
    Object.defineProperty(this, 'rowMode', {
        get: () =&gt; state.rowMode,
        set: value =&gt; {
            if (value !== state.rowMode) {
                state.rowMode = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#rows
     * @type {number}
     * @description
     * Number of rows to return at a time from a Prepared Statement's portal.
     * The default is 0, which means that all rows must be returned at once.
     */
    Object.defineProperty(this, 'rows', {
        get: () =&gt; state.rows,
        set: val ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.PromiseAdapter" id="apidoc.element.pg-promise.PromiseAdapter">
        function <span class="apidocSignatureSpan">pg-promise.</span>PromiseAdapter
        <span class="apidocSignatureSpan">(create, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PromiseAdapter(create, resolve, reject) {

    if (!(this instanceof PromiseAdapter)) {
        return new PromiseAdapter(create, resolve, reject);
    }

    this.create = create;
    this.resolve = resolve;
    this.reject = reject;

    if (typeof create !== 'function') {
        throw new TypeError('Adapter requires a function to create a promise.');
    }

    if (typeof resolve !== 'function') {
        throw new TypeError('Adapter requires a function to resolve a promise.');
    }

    if (typeof reject !== 'function') {
        throw new TypeError('Adapter requires a function to reject a promise.');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.QueryFile" id="apidoc.element.pg-promise.QueryFile">
        function <span class="apidocSignatureSpan">pg-promise.</span>QueryFile
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryFile(file, options) {

    if (!(this instanceof QueryFile)) {
        return new QueryFile(file, options);
    }

    var sql, error, ready, modTime, after, filePath = file, opt = {
        debug: $npm.utils.isDev(),
        minify: false,
        compress: false
    };

    if (options &amp;&amp; typeof options === 'object') {
        if (options.debug !== undefined) {
            opt.debug = !!options.debug;
        }
        if (options.minify !== undefined) {
            after = options.minify === 'after';
            opt.minify = after ? 'after' : !!options.minify;
        }
        if (options.compress !== undefined) {
            opt.compress = !!options.compress;
        }
        if (opt.compress &amp;&amp; options.minify === undefined) {
            opt.minify = true;
        }
        if (options.params !== undefined) {
            opt.params = options.params;
        }
    }

    Object.freeze(opt);

    if ($npm.utils.isText(filePath) &amp;&amp; !$npm.utils.isPathAbsolute(filePath)) {
        filePath = $npm.path.join($npm.utils.startDir, filePath);
    }

    // Custom Type Formatting support:
    this.formatDBType = function () {
        this.prepare(true);
        return this.query;
    };

    /**
     * @method QueryFile.prepare
     * @summary Prepares the query for execution.
     * @description
     * If the the query hasn't been prepared yet, it will read the file and process the contents according
     * to the parameters passed into the constructor.
     *
     * This method is primarily for internal use by the library.
     *
     * @param {boolean} [throwErrors=false]
     * Throw any error encountered.
     *
     */
    this.prepare = function (throwErrors) {
        var lastMod;
        if (opt.debug &amp;&amp; ready) {
            try {
                lastMod = $npm.fs.statSync(filePath).mtime.getTime();
                if (lastMod === modTime) {
                    // istanbul ignore next;
                    // coverage for this works differently under Windows and Linux
                    return;
                }
                ready = false;
            } catch (e) {
                sql = undefined;
                ready = false;
                error = e;
                if (throwErrors) {
                    throw error;
                }
                return;
            }
        }
        if (ready) {
            return;
        }
        try {
            sql = $npm.fs.readFileSync(filePath, 'utf8');
            modTime = lastMod || $npm.fs.statSync(filePath).mtime.getTime();
            if (opt.minify &amp;&amp; !after) {
                sql = $npm.minify(sql, {compress: opt.compress});
            }
            if (opt.params !== undefined) {
                sql = $npm.format(sql, opt.params, {partial: true});
            }
            if (opt.minify &amp;&amp; after) {
                sql = $npm.minify(sql, {compress: opt.compress});
            }
            ready = true;
            error = undefined;
        } catch (e) {
            sql = undefined;
            error = new $npm.QueryFileError(e, this);
            if (throwErrors) {
                throw error;
            }
        }
    };

    /**
     * @name QueryFile#query
     * @type {string}
     * @default undefined
     * @readonly
     * @summary Prepared query string.
     * @description
     * When property {@link QueryFile#error error} is set, the query is `undefined`.
     *
     * This property is primarily for internal use by the library.
     */
    Object.defineProperty(this, 'query', {
        get: () =&gt; sql
    });

    /**
     * @name QueryFile#error
     * @type {errors.QueryFileError}
     * @default undefined
     * @readonly
     * @description
     * When in an error state, it is set to a {@link errors.QueryFileError QueryFileError} object. Otherwise, it is `undefined`.
     *
     * This property is primarily for internal use by the library.
     */
    Object.defineProperty(this, 'error', { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example:

```js
// Helper for linking to external query files:
function sql(file) {
// consider using here: path.join(__dirname, file)
return new pgp.<span class="apidocCodeKeywordSpan">QueryFile</span>(file, {minify: true});
}

// Create QueryFile globally, once per file:
var sqlFindUser = sql('./sql/findUser.sql');

db.one(sqlFindUser, {id: 123})
.then(user=&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.ParameterizedQueryError" id="apidoc.element.pg-promise.errors.ParameterizedQueryError">
        function <span class="apidocSignatureSpan">pg-promise.</span>errors.ParameterizedQueryError
        <span class="apidocSignatureSpan">(error, ps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParameterizedQueryError(error, ps) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'ParameterizedQueryError';
    this.stack = temp.stack;
    if (error instanceof $npm.QueryFileError) {
        this.error = error;
        this.message = 'Failed to initialize \'text\' from a QueryFile.';
    } else {
        this.message = error;
    }
    this.result = ps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.PreparedStatementError" id="apidoc.element.pg-promise.errors.PreparedStatementError">
        function <span class="apidocSignatureSpan">pg-promise.</span>errors.PreparedStatementError
        <span class="apidocSignatureSpan">(error, ps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PreparedStatementError(error, ps) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'PreparedStatementError';
    this.stack = temp.stack;
    if (error instanceof $npm.QueryFileError) {
        this.error = error;
        this.message = 'Failed to initialize \'text\' from a QueryFile.';
    } else {
        this.message = error;
    }
    this.result = ps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryFileError" id="apidoc.element.pg-promise.errors.QueryFileError">
        function <span class="apidocSignatureSpan">pg-promise.</span>errors.QueryFileError
        <span class="apidocSignatureSpan">(error, qf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryFileError(error, qf) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'QueryFileError';
    this.stack = temp.stack;
    if (error instanceof $npm.minify.SQLParsingError) {
        this.error = error;
        this.message = 'Failed to parse the SQL.';
    } else {
        this.message = error.message;
    }
    this.file = qf.file;
    this.options = qf.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryResultError" id="apidoc.element.pg-promise.errors.QueryResultError">
        function <span class="apidocSignatureSpan">pg-promise.</span>errors.QueryResultError
        <span class="apidocSignatureSpan">(code, result, query, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryResultError(code, result, query, values) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'QueryResultError';
    this.stack = temp.stack;
    this.message = errorMessages[code].message;
    this.code = code;
    this.result = result;
    this.query = query;
    this.values = values;
    this.received = result.rows.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.minify" id="apidoc.element.pg-promise.minify">
        function <span class="apidocSignatureSpan">pg-promise.</span>minify
        <span class="apidocSignatureSpan">(sql, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minify(sql, options) {

    if (typeof sql !== 'string') {
        throw new TypeError("Input SQL must be a text string.");
    }

    if (options !== undefined &amp;&amp; typeof options !== 'object') {
        throw new TypeError("Parameter 'options' must be an object.");
    }

    if (!sql.length) {
        return '';
    }

    var idx = 0, // current index
        result = '', // resulting sql
        len = sql.length, // sql length
        EOL = getEOL(sql), // end-of-line
        space = false, // add a space on the next step
        compress = options &amp;&amp; options.compress; // option 'compress'

    do {
        var s = sql[idx], // current symbol;
            s1 = idx &lt; len - 1 ? sql[idx + 1] : ''; // next symbol;

        if (isGap(s)) {
            while (++idx &lt; len &amp;&amp; isGap(sql[idx]));
            if (idx &lt; len) {
                space = true;
            }
            idx--;
            continue;
        }

        if (s === '-' &amp;&amp; s1 === '-') {
            var lb = sql.indexOf(EOL, idx + 2);
            if (lb &lt; 0) {
                break;
            }
            idx = lb - 1;
            skipGaps();
            continue;
        }

        if (s === '/' &amp;&amp; s1 === '*') {
            var end = sql.indexOf('*/', idx + 2);
            if (end &lt; 0) {
                throwError(PEC.unclosedMLC);
            }
            idx = end + 1;
            skipGaps();
            continue;
        }

        if (s === '"') {
            var closeIdx = sql.indexOf('"', idx + 1);
            if (closeIdx &lt; 0) {
                throwError(PEC.unclosedQI);
            }
            var text = sql.substr(idx, closeIdx - idx + 1);
            if (text.indexOf(EOL) &gt; 0) {
                throwError(PEC.multiLineQI);
            }
            if (compress) {
                space = false;
            }
            addSpace();
            result += text;
            idx = closeIdx;
            skipGaps();
            continue;
        }

        if (s === '\'') {
            var closeIdx = idx;
            do {
                closeIdx = sql.indexOf('\'', closeIdx + 1);
                if (closeIdx &gt; 0) {
                    var step = closeIdx;
                    while (++step &lt; len &amp;&amp; sql[step] === '\'');
                    if ((step - closeIdx) % 2) {
                        closeIdx = step - 1;
                        break;
                    }
                    closeIdx = step === len ? -1 : step;
                }
            } while (closeIdx &gt; 0);
            if (closeIdx &lt; 0) {
                throwError(PEC.unclosedText);
            }
            if (compress) {
                space = false;
            }
            addSpace();
            var text = sql.substr(idx, closeIdx - idx + 1);
            var hasLB = text.indexOf(EOL) &gt; 0;
            if (hasLB) {
                text = text.split(EOL).map(function (m) {
                    return m.replace(/^\s+|\s+$/g, '');
                }).join('\\n');
            }
            var hasTabs = text.indexOf('\t') &gt; 0;
            if (hasLB || hasTabs) {
                var prev = idx ? sql[idx - 1] : '';
                if (prev !== 'E' &amp;&amp; prev !== 'e') {
                    var r = result ? result[result.length - 1] : '';
                    if (r &amp;&amp; r !== ' ' &amp;&amp; compressors.indexOf(r) &lt; 0) {
                        result += ' ';
                    }
                    result += 'E';
                }
                if (hasTabs) {
                    text = text.replace(/\t/g, '\\t');
                }
            }
            result += text;
            idx = closeIdx;
            skipGaps();
            continue;
        }

        if (compress &amp;&amp; compressors.indexOf(s) &gt;= 0) {
            space = false;
            skipGaps();
        }

        addSpace();
        result += s;

    } while (++idx &lt; len);

    return result;

    function skipGaps() {
        if (compress) {
            while (idx &lt; len - 1 &amp;&amp; isGap(sql[id ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.minify.SQLParsingError" id="apidoc.element.pg-promise.minify.SQLParsingError">
        function <span class="apidocSignatureSpan">pg-promise.</span>minify.SQLParsingError
        <span class="apidocSignatureSpan">(code, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SQLParsingError(code, position) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'SQLParsingError';
    this.stack = temp.stack;
    this.code = code; // one of parsingErrorCode values;
    this.error = errorMessages[code].message;
    this.position = position; // Error position in the text: {line, column}
    this.message = "Error parsing SQL at {line:" + position.line + ",col:" + position.column + "}: " + this.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.ParameterizedQuery" id="apidoc.module.pg-promise.ParameterizedQuery">module pg-promise.ParameterizedQuery</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.ParameterizedQuery.ParameterizedQuery" id="apidoc.element.pg-promise.ParameterizedQuery.ParameterizedQuery">
        function <span class="apidocSignatureSpan">pg-promise.</span>ParameterizedQuery
        <span class="apidocSignatureSpan">(text, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParameterizedQuery(text, values) {
    if (!(this instanceof ParameterizedQuery)) {
        return new ParameterizedQuery(text, values);
    }

    var currentError, PQ = {}, changed = true, state = {
        text: text,
        binary: undefined,
        rowMode: undefined
    };

    function setValues(v) {
        if (Array.isArray(v)) {
            if (v.length) {
                PQ.values = v;
            } else {
                delete PQ.values;
            }
        } else {
            if ($npm.utils.isNull(v)) {
                delete PQ.values;
            } else {
                PQ.values = [v];
            }
        }
    }

    setValues(values);

    /**
     * @name ParameterizedQuery#text
     * @type {string|QueryFile}
     * @description
     * A non-empty query string or a {@link QueryFile} object.
     */
    Object.defineProperty(this, 'text', {
        get: () =&gt; state.text,
        set: value =&gt; {
            if (value !== state.text) {
                state.text = value;
                changed = true;
            }
        }
    });

    /**
     * @name ParameterizedQuery#values
     * @type {array}
     * @description
     * Query formatting parameters, depending on the type:
     *
     * - `null` / `undefined` means the query has no formatting parameters
     * - `Array` - it is an array of formatting parameters
     * - None of the above, means it is a single formatting value, which
     *   is then automatically wrapped into an array
     */
    Object.defineProperty(this, 'values', {
        get: () =&gt; PQ.values,
        set: value =&gt; {
            setValues(value);
        }
    });

    /**
     * @name ParameterizedQuery#binary
     * @type {boolean}
     * @default undefined
     * @description
     * Activates binary result mode. The default is the text mode.
     *
     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}
     */
    Object.defineProperty(this, 'binary', {
        get: () =&gt; state.binary,
        set: value =&gt; {
            if (value !== state.binary) {
                state.binary = value;
                changed = true;
            }
        }
    });

    /**
     * @name ParameterizedQuery#rowMode
     * @type {string}
     * @default undefined
     * @description
     * Changes the way data arrives to the client, with only one value supported by $[pg]:
     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.
     *    By default, rows arrive as objects.
     */
    Object.defineProperty(this, 'rowMode', {
        get: () =&gt; state.rowMode,
        set: value =&gt; {
            if (value !== state.rowMode) {
                state.rowMode = value;
                changed = true;
            }
        }
    });

    /**
     * @name ParameterizedQuery#error
     * @type {errors.ParameterizedQueryError}
     * @default undefined
     * @readonly
     * @description
     * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise,
it is `undefined`.
     *
     * This property is primarily for internal use by the library.
     */
    Object.defineProperty(this, 'error', {
        get: () =&gt; currentError
    });

    if ($npm.utils.isObject(text, ['text'])) {
        state.text = text.text;
        state.binary = text.binary;
        state.rowMode = text.rowMode;
        setValues(text.values);
    }

    /**
     * @method ParameterizedQuery.parse
     * @description
     * Parses the current object and returns a simple `{text, values}`, if successful,
     * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.
     *
     * This method is primarily for internal use by the library.
     *
     * @returns {{text, values}|errors.ParameterizedQueryError}
     */
    this.parse = () =&gt; {

        var qf = state.text instanceof $npm.QueryFile ? s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.ParameterizedQuery.prototype" id="apidoc.module.pg-promise.ParameterizedQuery.prototype">module pg-promise.ParameterizedQuery.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.ParameterizedQuery.prototype.toString" id="apidoc.element.pg-promise.ParameterizedQuery.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.ParameterizedQuery.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap = $npm.utils.messageGap(level + 1);
    var pq = this.parse();
    var lines = [
        'ParameterizedQuery {'
    ];
    if ($npm.utils.isText(pq.text)) {
        lines.push(gap + 'text: "' + pq.text + '"');
    }
    if (this.values !== undefined) {
        lines.push(gap + 'values: ' + JSON.stringify(this.values));
    }
    if (this.binary !== undefined) {
        lines.push(gap + 'binary: ' + JSON.stringify(this.binary));
    }
    if (this.rowMode !== undefined) {
        lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));
    }
    if (this.error !== undefined) {
        lines.push(gap + 'error: ' + this.error.toString(level + 1));
    }
    lines.push($npm.utils.messageGap(level) + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.PreparedStatement" id="apidoc.module.pg-promise.PreparedStatement">module pg-promise.PreparedStatement</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.PreparedStatement.PreparedStatement" id="apidoc.element.pg-promise.PreparedStatement.PreparedStatement">
        function <span class="apidocSignatureSpan">pg-promise.</span>PreparedStatement
        <span class="apidocSignatureSpan">(name, text, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PreparedStatement(name, text, values) {
    if (!(this instanceof PreparedStatement)) {
        return new PreparedStatement(name, text, values);
    }

    var currentError, PS = {}, changed = true, state = {
        name: name,
        text: text,
        binary: undefined,
        rowMode: undefined,
        rows: undefined
    };

    function setValues(v) {
        if (Array.isArray(v)) {
            if (v.length) {
                PS.values = v;
            } else {
                delete PS.values;
            }
        } else {
            if ($npm.utils.isNull(v)) {
                delete PS.values;
            } else {
                PS.values = [v];
            }
        }
    }

    setValues(values);

    /**
     * @name PreparedStatement#name
     * @type {string}
     * @description
     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is
     * subsequently used to execute or deallocate a previously prepared statement.
     */
    Object.defineProperty(this, 'name', {
        get: () =&gt; state.name,
        set: value =&gt; {
            if (value !== state.name) {
                state.name = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#text
     * @type {string|QueryFile}
     * @description
     * A non-empty query string or a {@link QueryFile} object.
     *
     * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries
     * for Prepared Statements are cached, with {@link PreparedStatement#name name} being the cache key.
     */
    Object.defineProperty(this, 'text', {
        get: () =&gt; state.text,
        set: value =&gt; {
            if (value !== state.text) {
                state.text = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#values
     * @type {array}
     * @description
     * Query formatting parameters, depending on the type:
     *
     * - `null` / `undefined` means the query has no formatting parameters
     * - `Array` - it is an array of formatting parameters
     * - None of the above, means it is a single formatting value, which
     *   is then automatically wrapped into an array
     */
    Object.defineProperty(this, 'values', {
        get: () =&gt; PS.values,
        set: value =&gt; {
            setValues(value);
        }
    });

    /**
     * @name PreparedStatement#binary
     * @type {boolean}
     * @default undefined
     * @description
     * Activates binary result mode. The default is the text mode.
     *
     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}
     */
    Object.defineProperty(this, 'binary', {
        get: () =&gt; state.binary,
        set: value =&gt; {
            if (value !== state.binary) {
                state.binary = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#rowMode
     * @type {string}
     * @default undefined
     * @description
     * Changes the way data arrives to the client, with only one value supported by $[pg]:
     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.
     *    By default, rows arrive as objects.
     */
    Object.defineProperty(this, 'rowMode', {
        get: () =&gt; state.rowMode,
        set: value =&gt; {
            if (value !== state.rowMode) {
                state.rowMode = value;
                changed = true;
            }
        }
    });

    /**
     * @name PreparedStatement#rows
     * @type {number}
     * @description
     * Number of rows to return at a time from a Prepared Statement's portal.
     * The default is 0, which means that all rows must be returned at once.
     */
    Object.defineProperty(this, 'rows', {
        get: () =&gt; state.rows,
        set: val ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.PreparedStatement.prototype" id="apidoc.module.pg-promise.PreparedStatement.prototype">module pg-promise.PreparedStatement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.PreparedStatement.prototype.toString" id="apidoc.element.pg-promise.PreparedStatement.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.PreparedStatement.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap = $npm.utils.messageGap(level + 1);
    var ps = this.parse();
    var lines = [
        'PreparedStatement {',
        gap + 'name: ' + JSON.stringify(this.name)
    ];
    if ($npm.utils.isText(ps.text)) {
        lines.push(gap + 'text: "' + ps.text + '"');
    }
    if (this.values !== undefined) {
        lines.push(gap + 'values: ' + JSON.stringify(this.values));
    }
    if (this.binary !== undefined) {
        lines.push(gap + 'binary: ' + JSON.stringify(this.binary));
    }
    if (this.rowMode !== undefined) {
        lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));
    }
    if (this.rows !== undefined) {
        lines.push(gap + 'rows: ' + JSON.stringify(this.rows));
    }
    if (this.error) {
        lines.push(gap + 'error: ' + this.error.toString(level + 1));
    }
    lines.push($npm.utils.messageGap(level) + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.QueryFile" id="apidoc.module.pg-promise.QueryFile">module pg-promise.QueryFile</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.QueryFile.QueryFile" id="apidoc.element.pg-promise.QueryFile.QueryFile">
        function <span class="apidocSignatureSpan">pg-promise.</span>QueryFile
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryFile(file, options) {

    if (!(this instanceof QueryFile)) {
        return new QueryFile(file, options);
    }

    var sql, error, ready, modTime, after, filePath = file, opt = {
        debug: $npm.utils.isDev(),
        minify: false,
        compress: false
    };

    if (options &amp;&amp; typeof options === 'object') {
        if (options.debug !== undefined) {
            opt.debug = !!options.debug;
        }
        if (options.minify !== undefined) {
            after = options.minify === 'after';
            opt.minify = after ? 'after' : !!options.minify;
        }
        if (options.compress !== undefined) {
            opt.compress = !!options.compress;
        }
        if (opt.compress &amp;&amp; options.minify === undefined) {
            opt.minify = true;
        }
        if (options.params !== undefined) {
            opt.params = options.params;
        }
    }

    Object.freeze(opt);

    if ($npm.utils.isText(filePath) &amp;&amp; !$npm.utils.isPathAbsolute(filePath)) {
        filePath = $npm.path.join($npm.utils.startDir, filePath);
    }

    // Custom Type Formatting support:
    this.formatDBType = function () {
        this.prepare(true);
        return this.query;
    };

    /**
     * @method QueryFile.prepare
     * @summary Prepares the query for execution.
     * @description
     * If the the query hasn't been prepared yet, it will read the file and process the contents according
     * to the parameters passed into the constructor.
     *
     * This method is primarily for internal use by the library.
     *
     * @param {boolean} [throwErrors=false]
     * Throw any error encountered.
     *
     */
    this.prepare = function (throwErrors) {
        var lastMod;
        if (opt.debug &amp;&amp; ready) {
            try {
                lastMod = $npm.fs.statSync(filePath).mtime.getTime();
                if (lastMod === modTime) {
                    // istanbul ignore next;
                    // coverage for this works differently under Windows and Linux
                    return;
                }
                ready = false;
            } catch (e) {
                sql = undefined;
                ready = false;
                error = e;
                if (throwErrors) {
                    throw error;
                }
                return;
            }
        }
        if (ready) {
            return;
        }
        try {
            sql = $npm.fs.readFileSync(filePath, 'utf8');
            modTime = lastMod || $npm.fs.statSync(filePath).mtime.getTime();
            if (opt.minify &amp;&amp; !after) {
                sql = $npm.minify(sql, {compress: opt.compress});
            }
            if (opt.params !== undefined) {
                sql = $npm.format(sql, opt.params, {partial: true});
            }
            if (opt.minify &amp;&amp; after) {
                sql = $npm.minify(sql, {compress: opt.compress});
            }
            ready = true;
            error = undefined;
        } catch (e) {
            sql = undefined;
            error = new $npm.QueryFileError(e, this);
            if (throwErrors) {
                throw error;
            }
        }
    };

    /**
     * @name QueryFile#query
     * @type {string}
     * @default undefined
     * @readonly
     * @summary Prepared query string.
     * @description
     * When property {@link QueryFile#error error} is set, the query is `undefined`.
     *
     * This property is primarily for internal use by the library.
     */
    Object.defineProperty(this, 'query', {
        get: () =&gt; sql
    });

    /**
     * @name QueryFile#error
     * @type {errors.QueryFileError}
     * @default undefined
     * @readonly
     * @description
     * When in an error state, it is set to a {@link errors.QueryFileError QueryFileError} object. Otherwise, it is `undefined`.
     *
     * This property is primarily for internal use by the library.
     */
    Object.defineProperty(this, 'error', { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example:

```js
// Helper for linking to external query files:
function sql(file) {
// consider using here: path.join(__dirname, file)
return new pgp.<span class="apidocCodeKeywordSpan">QueryFile</span>(file, {minify: true});
}

// Create QueryFile globally, once per file:
var sqlFindUser = sql('./sql/findUser.sql');

db.one(sqlFindUser, {id: 123})
.then(user=&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.QueryFile.prototype" id="apidoc.module.pg-promise.QueryFile.prototype">module pg-promise.QueryFile.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.QueryFile.prototype.inspect" id="apidoc.element.pg-promise.QueryFile.prototype.inspect">
        function <span class="apidocSignatureSpan">pg-promise.QueryFile.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.QueryFile.prototype.toString" id="apidoc.element.pg-promise.QueryFile.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.QueryFile.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap = $npm.utils.messageGap(level + 1);
    var lines = [
        'QueryFile {'
    ];
    this.prepare();
    lines.push(gap + 'file: "' + this.file + '"');
    lines.push(gap + 'options: ' + JSON.stringify(this.options));
    if (this.error) {
        lines.push(gap + 'error: ' + this.error.toString(level + 1));
    } else {
        lines.push(gap + 'query: "' + this.query + '"');
    }
    lines.push($npm.utils.messageGap(level) + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.array" id="apidoc.module.pg-promise.array">module pg-promise.array</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.array.countIf" id="apidoc.element.pg-promise.array.countIf">
        function <span class="apidocSignatureSpan">pg-promise.array.</span>countIf
        <span class="apidocSignatureSpan">(arr, cb, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function countIf(arr, cb, obj) {
    var count = 0;
    if (obj) {
        for (var i = 0; i &lt; arr.length; i++) {
            count += cb.call(obj, arr[i], i, arr) ? 1 : 0;
        }
    } else {
        for (var k = 0; k &lt; arr.length; k++) {
            count += cb(arr[k], k, arr) ? 1 : 0;
        }
    }
    return count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.array.filter" id="apidoc.element.pg-promise.array.filter">
        function <span class="apidocSignatureSpan">pg-promise.array.</span>filter
        <span class="apidocSignatureSpan">(arr, cb, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(arr, cb, obj) {
    var res = [];
    if (obj) {
        for (var i = 0; i &lt; arr.length; i++) {
            if (cb.call(obj, arr[i], i, arr)) {
                res.push(arr[i]);
            }
        }
    } else {
        for (var k = 0; k &lt; arr.length; k++) {
            if (cb(arr[k], k, arr)) {
                res.push(arr[k]);
            }
        }
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.array.forEach" id="apidoc.element.pg-promise.array.forEach">
        function <span class="apidocSignatureSpan">pg-promise.array.</span>forEach
        <span class="apidocSignatureSpan">(arr, cb, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach(arr, cb, obj) {
    if (obj) {
        for (var i = 0; i &lt; arr.length; i++) {
            cb.call(obj, arr[i], i, arr);
        }
    } else {
        for (var k = 0; k &lt; arr.length; k++) {
            cb(arr[k], k, arr);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Executes a provided function once per array element, for an array of rows resolved by method {@link Database.any any}.
*
* It is a convenience method to reduce the following code:
*
* ```js
* db.any(query, values)
*     .then(data =&gt; {
*         data.<span class="apidocCodeKeywordSpan">forEach</span>((row, index, data) =&gt; {
*              // process the row
*         });
*         return data;
*     });
* ```
*
* In addition to much shorter code, it offers the following benefits:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.array.map" id="apidoc.element.pg-promise.array.map">
        function <span class="apidocSignatureSpan">pg-promise.array.</span>map
        <span class="apidocSignatureSpan">(arr, cb, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(arr, cb, obj) {
    var res = new Array(arr.length);
    if (obj) {
        for (var i = 0; i &lt; arr.length; i++) {
            res[i] = cb.call(obj, arr[i], i, arr);
        }
    } else {
        for (var k = 0; k &lt; arr.length; k++) {
            res[k] = cb(arr[k], k, arr);
        }
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
query('INSERT INTO $1~($2~) VALUES(...)', ['Table Name', 'Column Name']);
//=&gt; INSERT INTO "Table Name"("Column Name") VALUES(...)

// A mixed example for a dynamic column list:
var columns = ['id', 'message'];
query('SELECT ${columns^} FROM ${table~}', {
    columns: columns.<span class="apidocCodeKeywordSpan">map</span>(pgp.as.name).join(),
    table: 'Table Name'
});
//=&gt; SELECT "id","message" FROM "Table Name"
```

Version 5.2.1 and later supports extended syntax for `${this~}` and for method [as.name]:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.as" id="apidoc.module.pg-promise.as">module pg-promise.as</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.as.array" id="apidoc.element.pg-promise.as.array">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>array
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arr =&gt; {
    arr = resolveFunc(arr);
    if (isNull(arr)) {
        return 'null';
    }
    if (arr instanceof Array) {
        return formatArray(arr);
    }
    throw new TypeError(wrapText(arr) + ' is not an Array object.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   - format `$1` (single variable), if `values` is of type `string`, `boolean`, `number`, `Date`, `function`, `null` or [QueryFile
];
   - format `$1, $2, etc..`, if `values` is an array;
   - format `$*propName*`, if `values` is an object (not `null` and not `Date`), where `*` is any of the supported open-close pairs
: `{}`, `()`, `&lt;&gt;`, `[]`, `//`;
* `values` (optional) - value/array/object to replace the variables in the query;
* `qrm` - (optional) *Query Result Mask*, as explained below. When not passed, it defaults to `pgp.queryResult.any`.

When a value/property inside array/object is an array, it is treated as a [PostgreSQL Array Type](http://www.postgresql.org/docs
/9.4/static/arrays.html),
converted into the array constructor format of `array[]`, the same as calling method `pgp.as.<span class="apidocCodeKeywordSpan">
array</span>()`.

When a value/property inside array/object is of type `object` (except for `null`, `Date` or `Buffer`), it is automatically
serialized into JSON, the same as calling method `pgp.as.json()`, except the latter would convert anything to JSON.

For the latest SQL formatting support see the API: methods [query] and [as.format].

### SQL Names
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.bool" id="apidoc.element.pg-promise.as.bool">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>bool
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
        return 'null';
    }
    return value ? 'true' : 'false';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return 'null';
}

switch (typeof value) {
    case 'string':
        return $as.text(value, isRaw);
    case 'boolean':
        return $as.<span class="apidocCodeKeywordSpan">bool</span>(value);
    case 'number':
        return $as.number(value);
    default:
        if (value instanceof Date) {
            return $as.date(value, isRaw);
        }
        if (value instanceof Array) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.buffer" id="apidoc.element.pg-promise.as.buffer">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>buffer
        <span class="apidocSignatureSpan">(obj, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(obj, raw) =&gt; {
    obj = resolveFunc(obj);
    if (isNull(obj)) {
        throwIfRaw(raw);
        return 'null';
    }
    if (obj instanceof Buffer) {
        var s = '\\x' + obj.toString('hex');
        return raw ? s : wrapText(s);
    }
    throw new TypeError(wrapText(obj) + ' is not a Buffer object.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (value instanceof Date) {
                return $as.date(value, isRaw);
            }
            if (value instanceof Array) {
                return $as.array(value);
            }
            if (value instanceof Buffer) {
                return $as.<span class="apidocCodeKeywordSpan">buffer</span>(value, isRaw);
            }
            return $as.json(value, isRaw);
    }
}

//////////////////////////////////////////////////////////////////////////
// Converts array of values into PostgreSQL Array Constructor: array[...],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.csv" id="apidoc.element.pg-promise.as.csv">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>csv
        <span class="apidocSignatureSpan">(resolveFunc(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values =&gt; formatCSV(resolveFunc(values))</pre></li>
    <li>example usage<pre class="apidocCodePre">...

switch (fm) {
    case fmFlags.name:
        return $as.name(value);
    case fmFlags.json:
        return $as.json(value, isRaw);
    case fmFlags.csv:
        return $as.<span class="apidocCodeKeywordSpan">csv</span>(value);
    case fmFlags.value:
        return $as.value(value);
    default:
        break;
}

if (isNull(value)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.date" id="apidoc.element.pg-promise.as.date">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>date
        <span class="apidocSignatureSpan">(d, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(d, raw) =&gt; {
    d = resolveFunc(d);
    if (isNull(d)) {
        throwIfRaw(raw);
        return 'null';
    }
    if (d instanceof Date) {
        var s = $pgUtils.prepareValue(d);
        return raw ? s : wrapText(s);
    }
    throw new TypeError(wrapText(d) + ' is not a Date object.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return $as.text(value, isRaw);
case 'boolean':
    return $as.bool(value);
case 'number':
    return $as.number(value);
default:
    if (value instanceof Date) {
        return $as.<span class="apidocCodeKeywordSpan">date</span>(value, isRaw);
    }
    if (value instanceof Array) {
        return $as.array(value);
    }
    if (value instanceof Buffer) {
        return $as.buffer(value, isRaw);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.format" id="apidoc.element.pg-promise.as.format">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>format
        <span class="apidocSignatureSpan">(query, values, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(query, values, options) =&gt; {
    if (query &amp;&amp; typeof query.formatDBType === 'function') {
        query = query.formatDBType();
    }
    return $formatQuery(query, values, false, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {external:Stream} stream
* Stream object to initialize streaming.
*
* @example
* var QueryStream = require('pg-query-stream');
* var JSONStream = require('JSONStream');
*
* // you can also use pgp.as.<span class="apidocCodeKeywordSpan">format</span>(query, values, options)
* // to format queries properly, via pg-promise;
* var qs = new QueryStream('select * from users');
*
* db.stream(qs, stream =&gt; {
*         // initiate streaming into the console:
*         stream.pipe(JSONStream.stringify()).pipe(process.stdout);
*     })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.func" id="apidoc.element.pg-promise.as.func">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>func
        <span class="apidocSignatureSpan">(func, raw, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(func, raw, obj) =&gt; {
    if (isNull(func)) {
        throwIfRaw(raw);
        return 'null';
    }
    if (typeof func !== 'function') {
        throw new TypeError(wrapText(func) + ' is not a function.');
    }
    var fm = raw ? fmFlags.raw : null;
    if (isNull(obj)) {
        return formatValue(resolveFunc(func), fm);
    }
    if (typeof obj === 'object') {
        return formatValue(resolveFunc(func, obj), fm, obj);
    }
    throw new TypeError(wrapText(obj) + ' is not an object.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

In PostgreSQL stored procedures are just functions that usually do not return anything.

Suppose we want to call function **findAudit** to find audit records by `user_id` and maximum timestamp.
We can make such call as shown below:

```js
db.<span class="apidocCodeKeywordSpan">func</span>('findAudit', [123, new Date()])
    .then(data =&gt; {
        console.log(data); // printing the data returned
    })
    .catch(error =&gt; {
        console.log(error); // printing the error
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.json" id="apidoc.element.pg-promise.as.json">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>json
        <span class="apidocSignatureSpan">(obj, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(obj, raw) =&gt; {
    obj = resolveFunc(obj);
    if (isNull(obj)) {
        throwIfRaw(raw);
        return 'null';
    }
    var s = JSON.stringify(obj);
    return raw ? s : wrapText(safeText(s));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `values` (optional) - value/array/object to replace the variables in the query;
* `qrm` - (optional) *Query Result Mask*, as explained below. When not passed, it defaults to `pgp.queryResult.any`.

When a value/property inside array/object is an array, it is treated as a [PostgreSQL Array Type](http://www.postgresql.org/docs
/9.4/static/arrays.html),
converted into the array constructor format of `array[]`, the same as calling method `pgp.as.array()`.

When a value/property inside array/object is of type `object` (except for `null`, `Date` or `Buffer`), it is automatically
serialized into JSON, the same as calling method `pgp.as.<span class="apidocCodeKeywordSpan">json</span>()`, except the latter would
 convert anything to JSON.

For the latest SQL formatting support see the API: methods [query] and [as.format].

### SQL Names

When a variable ends with `~` (tilde) or `:name`, it represents an SQL name or identifier, which must be a text
string of at least 1 character long. Such name is then properly escaped and wrapped in double quotes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.name" id="apidoc.element.pg-promise.as.name">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>name
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">name =&gt; {
    name = resolveFunc(name);
    if (name) {
        if (typeof name === 'string') {
            return /^\s*\*(\s*)$/.test(name) ? name : formatName(name);
        }
        if (typeof name === 'object') {
            var keys = Array.isArray(name) ? name : Object.keys(name);
            if (!keys.length) {
                throw new Error('Cannot retrieve sql names from an empty array/object.');
            }
            return $arr.map(keys, value =&gt; {
                if (!value || typeof value !== 'string') {
                    throw new Error('Invalid sql name: ' + JSON.stringify(value));
                }
                return formatName(value);
            }).join();
        }
    }

    throw new TypeError('Invalid sql name: ' + JSON.stringify(name));

    function formatName(name) {
        return '"' + name.replace(/"/g, '""') + '"';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var isRaw = !!(fm &amp; fmFlags.raw);
fm &amp;= ~fmFlags.raw;

switch (fm) {
    case fmFlags.name:
        return $as.<span class="apidocCodeKeywordSpan">name</span>(value);
    case fmFlags.json:
        return $as.json(value, isRaw);
    case fmFlags.csv:
        return $as.csv(value);
    case fmFlags.value:
        return $as.value(value);
    default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.number" id="apidoc.element.pg-promise.as.number">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>number
        <span class="apidocSignatureSpan">(num)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">num =&gt; {
    num = resolveFunc(num);
    if (isNull(num)) {
        return 'null';
    }
    if (typeof num !== 'number') {
        throw new TypeError(wrapText(num) + ' is not a number.');
    }
    if (isFinite(num)) {
        return num.toString();
    }
    // Converting NaN/+Infinity/-Infinity according to Postgres documentation:
    // http://www.postgresql.org/docs/9.4/static/datatype-numeric.html#DATATYPE-FLOAT
    //
    // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.
    if (num === Number.POSITIVE_INFINITY) {
        return wrapText('+Infinity');
    }
    if (num === Number.NEGATIVE_INFINITY) {
        return wrapText('-Infinity');
    }
    return wrapText('NaN');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    switch (typeof value) {
case 'string':
    return $as.text(value, isRaw);
case 'boolean':
    return $as.bool(value);
case 'number':
    return $as.<span class="apidocCodeKeywordSpan">number</span>(value);
default:
    if (value instanceof Date) {
        return $as.date(value, isRaw);
    }
    if (value instanceof Array) {
        return $as.array(value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.text" id="apidoc.element.pg-promise.as.text">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>text
        <span class="apidocSignatureSpan">(value, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
        throwIfRaw(raw);
        return 'null';
    }
    if (typeof value !== 'string') {
        value = value.toString();
    }
    return raw ? value : wrapText(safeText(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (isNull(value)) {
    throwIfRaw(isRaw);
    return 'null';
}

switch (typeof value) {
    case 'string':
        return $as.<span class="apidocCodeKeywordSpan">text</span>(value, isRaw);
    case 'boolean':
        return $as.bool(value);
    case 'number':
        return $as.number(value);
    default:
        if (value instanceof Date) {
            return $as.date(value, isRaw);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.as.value" id="apidoc.element.pg-promise.as.value">
        function <span class="apidocSignatureSpan">pg-promise.as.</span>value
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
        throw new TypeError('Open values cannot be null or undefined.');
    }
    return safeText(formatValue(value, fmFlags.raw));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case fmFlags.name:
        return $as.name(value);
    case fmFlags.json:
        return $as.json(value, isRaw);
    case fmFlags.csv:
        return $as.csv(value);
    case fmFlags.value:
        return $as.<span class="apidocCodeKeywordSpan">value</span>(value);
    default:
        break;
}

if (isNull(value)) {
    throwIfRaw(isRaw);
    return 'null';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors" id="apidoc.module.pg-promise.errors">module pg-promise.errors</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.ParameterizedQueryError" id="apidoc.element.pg-promise.errors.ParameterizedQueryError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>ParameterizedQueryError
        <span class="apidocSignatureSpan">(error, ps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParameterizedQueryError(error, ps) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'ParameterizedQueryError';
    this.stack = temp.stack;
    if (error instanceof $npm.QueryFileError) {
        this.error = error;
        this.message = 'Failed to initialize \'text\' from a QueryFile.';
    } else {
        this.message = error;
    }
    this.result = ps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.PreparedStatementError" id="apidoc.element.pg-promise.errors.PreparedStatementError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>PreparedStatementError
        <span class="apidocSignatureSpan">(error, ps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PreparedStatementError(error, ps) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'PreparedStatementError';
    this.stack = temp.stack;
    if (error instanceof $npm.QueryFileError) {
        this.error = error;
        this.message = 'Failed to initialize \'text\' from a QueryFile.';
    } else {
        this.message = error;
    }
    this.result = ps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryFileError" id="apidoc.element.pg-promise.errors.QueryFileError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryFileError
        <span class="apidocSignatureSpan">(error, qf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryFileError(error, qf) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'QueryFileError';
    this.stack = temp.stack;
    if (error instanceof $npm.minify.SQLParsingError) {
        this.error = error;
        this.message = 'Failed to parse the SQL.';
    } else {
        this.message = error.message;
    }
    this.file = qf.file;
    this.options = qf.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryResultError" id="apidoc.element.pg-promise.errors.QueryResultError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryResultError
        <span class="apidocSignatureSpan">(code, result, query, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryResultError(code, result, query, values) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'QueryResultError';
    this.stack = temp.stack;
    this.message = errorMessages[code].message;
    this.code = code;
    this.result = result;
    this.query = query;
    this.values = values;
    this.received = result.rows.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.ParameterizedQueryError" id="apidoc.module.pg-promise.errors.ParameterizedQueryError">module pg-promise.errors.ParameterizedQueryError</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.ParameterizedQueryError.ParameterizedQueryError" id="apidoc.element.pg-promise.errors.ParameterizedQueryError.ParameterizedQueryError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>ParameterizedQueryError
        <span class="apidocSignatureSpan">(error, ps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParameterizedQueryError(error, ps) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'ParameterizedQueryError';
    this.stack = temp.stack;
    if (error instanceof $npm.QueryFileError) {
        this.error = error;
        this.message = 'Failed to initialize \'text\' from a QueryFile.';
    } else {
        this.message = error;
    }
    this.result = ps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.ParameterizedQueryError.prototype" id="apidoc.module.pg-promise.errors.ParameterizedQueryError.prototype">module pg-promise.errors.ParameterizedQueryError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.ParameterizedQueryError.prototype.inspect" id="apidoc.element.pg-promise.errors.ParameterizedQueryError.prototype.inspect">
        function <span class="apidocSignatureSpan">pg-promise.errors.ParameterizedQueryError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.ParameterizedQueryError.prototype.toString" id="apidoc.element.pg-promise.errors.ParameterizedQueryError.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.errors.ParameterizedQueryError.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap0 = $npm.utils.messageGap(level),
        gap1 = $npm.utils.messageGap(level + 1),
        gap2 = $npm.utils.messageGap(level + 2),
        lines = [
            'ParameterizedQueryError {',
            gap1 + 'message: "' + this.message + '"',
            gap1 + 'result: {',
            gap2 + 'text: ' + JSON.stringify(this.result.text),
            gap2 + 'values: ' + JSON.stringify(this.result.values),
            gap1 + '}'
        ];
    if (this.error) {
        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));
    }
    lines.push(gap0 + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.PreparedStatementError" id="apidoc.module.pg-promise.errors.PreparedStatementError">module pg-promise.errors.PreparedStatementError</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.PreparedStatementError.PreparedStatementError" id="apidoc.element.pg-promise.errors.PreparedStatementError.PreparedStatementError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>PreparedStatementError
        <span class="apidocSignatureSpan">(error, ps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PreparedStatementError(error, ps) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'PreparedStatementError';
    this.stack = temp.stack;
    if (error instanceof $npm.QueryFileError) {
        this.error = error;
        this.message = 'Failed to initialize \'text\' from a QueryFile.';
    } else {
        this.message = error;
    }
    this.result = ps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.PreparedStatementError.prototype" id="apidoc.module.pg-promise.errors.PreparedStatementError.prototype">module pg-promise.errors.PreparedStatementError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.PreparedStatementError.prototype.inspect" id="apidoc.element.pg-promise.errors.PreparedStatementError.prototype.inspect">
        function <span class="apidocSignatureSpan">pg-promise.errors.PreparedStatementError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.PreparedStatementError.prototype.toString" id="apidoc.element.pg-promise.errors.PreparedStatementError.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.errors.PreparedStatementError.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap0 = $npm.utils.messageGap(level),
        gap1 = $npm.utils.messageGap(level + 1),
        gap2 = $npm.utils.messageGap(level + 2),
        lines = [
            'PreparedStatementError {',
            gap1 + 'message: "' + this.message + '"',
            gap1 + 'result: {',
            gap2 + 'name: ' + JSON.stringify(this.result.name),
            gap2 + 'text: ' + JSON.stringify(this.result.text),
            gap2 + 'values: ' + JSON.stringify(this.result.values),
            gap1 + '}'
        ];
    if (this.error) {
        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));
    }
    lines.push(gap0 + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.QueryFileError" id="apidoc.module.pg-promise.errors.QueryFileError">module pg-promise.errors.QueryFileError</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryFileError.QueryFileError" id="apidoc.element.pg-promise.errors.QueryFileError.QueryFileError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryFileError
        <span class="apidocSignatureSpan">(error, qf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryFileError(error, qf) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'QueryFileError';
    this.stack = temp.stack;
    if (error instanceof $npm.minify.SQLParsingError) {
        this.error = error;
        this.message = 'Failed to parse the SQL.';
    } else {
        this.message = error.message;
    }
    this.file = qf.file;
    this.options = qf.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.QueryFileError.prototype" id="apidoc.module.pg-promise.errors.QueryFileError.prototype">module pg-promise.errors.QueryFileError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryFileError.prototype.inspect" id="apidoc.element.pg-promise.errors.QueryFileError.prototype.inspect">
        function <span class="apidocSignatureSpan">pg-promise.errors.QueryFileError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryFileError.prototype.toString" id="apidoc.element.pg-promise.errors.QueryFileError.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.errors.QueryFileError.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap0 = $npm.utils.messageGap(level),
        gap1 = $npm.utils.messageGap(level + 1),
        lines = [
            'QueryFileError {',
            gap1 + 'message: "' + this.message + '"',
            gap1 + 'options: ' + JSON.stringify(this.options),
            gap1 + 'file: "' + this.file + '"'
        ];
    if (this.error) {
        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));
    }
    lines.push(gap0 + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.QueryResultError" id="apidoc.module.pg-promise.errors.QueryResultError">module pg-promise.errors.QueryResultError</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryResultError.QueryResultError" id="apidoc.element.pg-promise.errors.QueryResultError.QueryResultError">
        function <span class="apidocSignatureSpan">pg-promise.errors.</span>QueryResultError
        <span class="apidocSignatureSpan">(code, result, query, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryResultError(code, result, query, values) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'QueryResultError';
    this.stack = temp.stack;
    this.message = errorMessages[code].message;
    this.code = code;
    this.result = result;
    this.query = query;
    this.values = values;
    this.received = result.rows.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.errors.QueryResultError.prototype" id="apidoc.module.pg-promise.errors.QueryResultError.prototype">module pg-promise.errors.QueryResultError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryResultError.prototype.inspect" id="apidoc.element.pg-promise.errors.QueryResultError.prototype.inspect">
        function <span class="apidocSignatureSpan">pg-promise.errors.QueryResultError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.errors.QueryResultError.prototype.toString" id="apidoc.element.pg-promise.errors.QueryResultError.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.errors.QueryResultError.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap0 = $npm.utils.messageGap(level),
        gap1 = $npm.utils.messageGap(level + 1),
        lines = [
            'QueryResultError {',
            gap1 + 'code: queryResultErrorCode.' + errorMessages[this.code].name,
            gap1 + 'message: "' + this.message + '"',
            gap1 + 'received: ' + this.received,
            gap1 + 'query: ' + (typeof this.query === 'string' ? '"' + this.query + '"' : JSON.stringify(this.query))
        ];
    if (this.values !== undefined) {
        lines.push(gap1 + 'values: ' + JSON.stringify(this.values));
    }
    lines.push(gap0 + '}');
    return lines.join($npm.os.EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.events" id="apidoc.module.pg-promise.events">module pg-promise.events</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.events.connect" id="apidoc.element.pg-promise.events.connect">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>connect
        <span class="apidocSignatureSpan">(ctx, client, isFresh)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(ctx, client, isFresh) =&gt; {
    if (typeof ctx.options.connect === 'function') {
        try {
            ctx.options.connect(client, ctx.dc, isFresh);
        } catch (e) {
            // have to silence errors here;
            // cannot allow unhandled errors while connecting to the database,
            // as it will break the connection logic;
            $events.unexpected('connect', e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
con: require('manakin').local,
utils: require('./utils'),
events: require('./events')
};

function poolConnect(ctx, config) {
return config.promise((resolve, reject) =&gt; {
    config.pgp.pg.<span class="apidocCodeKeywordSpan">connect</span>(ctx.cn, (err, client, done) =&gt; {
        if (err) {
            $npm.events.error(ctx.options, err, {
                cn: $npm.utils.getSafeConnection(ctx.cn),
                dc: ctx.dc
            });
            reject(err);
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.disconnect" id="apidoc.element.pg-promise.events.disconnect">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>disconnect
        <span class="apidocSignatureSpan">(ctx, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(ctx, client) =&gt; {
    if (typeof ctx.options.disconnect === 'function') {
        try {
            ctx.options.disconnect(client, ctx.dc);
        } catch (e) {
            // have to silence errors here;
            // cannot allow unhandled errors while disconnecting from the database,
            // as it will break the disconnection logic;
            $events.unexpected('disconnect', e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                var end = lockClientEnd(client);
                resolve({
                    isFresh: isFresh,
                    client: client,
                    done: () =&gt; {
                        client.end = end;
                        done();
                        $npm.events.<span class="apidocCodeKeywordSpan">disconnect</span>(ctx, client);
                    }
                });
                $npm.events.connect(ctx, client, isFresh);
            }
        });
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.error" id="apidoc.element.pg-promise.events.error">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>error
        <span class="apidocSignatureSpan">(options, err, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, err, context) =&gt; {
    if (typeof options.error === 'function') {
        try {
            options.error(err, context);
        } catch (e) {
            // have to silence errors here;
            // throwing unhandled errors while handling an error
            // notification is simply not acceptable.
            $events.unexpected('error', e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
events: require('./events')
};

function poolConnect(ctx, config) {
return config.promise((resolve, reject) =&gt; {
    config.pgp.pg.connect(ctx.cn, (err, client, done) =&gt; {
        if (err) {
            $npm.events.<span class="apidocCodeKeywordSpan">error</span>(ctx.options, err, {
                cn: $npm.utils.getSafeConnection(ctx.cn),
                dc: ctx.dc
            });
            reject(err);
        } else {
            var isFresh = !client.$used;
            if (isFresh) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.extend" id="apidoc.element.pg-promise.events.extend">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>extend
        <span class="apidocSignatureSpan">(options, obj, dc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, obj, dc) =&gt; {
    if (typeof options.extend === 'function') {
        try {
            options.extend.call(obj, obj, dc);
        } catch (e) {
            // have to silence errors here;
            // the result of throwing unhandled errors while
            // extending the protocol would be unpredictable.
            $events.unexpected('extend', e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        // lock all default properties to read-only,
        // to prevent override by the client.
        $npm.utils.lock(obj, false, ctx.options);

        // extend the protocol;
        $npm.events.<span class="apidocCodeKeywordSpan">extend</span>(ctx.options, obj, ctx.dc);

        // freeze the protocol permanently;
        $npm.utils.lock(obj, true, ctx.options);
    }

}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.query" id="apidoc.element.pg-promise.events.query">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>query
        <span class="apidocSignatureSpan">(options, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, context) =&gt; {
    if (typeof options.query === 'function') {
        try {
            options.query(context);
        } catch (e) {
            // throwing an error during event 'query'
            // will result in a reject for the request.
            return e instanceof Error ? e : new $npm.utils.InternalError(e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    any: 6
};
```

In the following generic-query example we indicate that the call can return anything:

```js
db.<span class="apidocCodeKeywordSpan">query</span>('select * from users');
```

which is equivalent to making one of the following calls:

```js
var qrm = pgp.queryResult;
db.query('SELECT * FROM users', undefined, qrm.many | qrm.none);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.receive" id="apidoc.element.pg-promise.events.receive">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>receive
        <span class="apidocSignatureSpan">(options, data, result, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, data, result, context) =&gt; {
    if (typeof options.receive === 'function') {
        try {
            options.receive(data, result, context);
        } catch (e) {
            // throwing an error during event 'receive'
            // will result in a reject for the request.
            return e instanceof Error ? e : new $npm.utils.InternalError(e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         }
 *     }
 * }
 */
receive: (options, data, result, context) =&gt; {
    if (typeof options.receive === 'function') {
        try {
            options.<span class="apidocCodeKeywordSpan">receive</span>(data, result, context);
        } catch (e) {
            // throwing an error during event 'receive'
            // will result in a reject for the request.
            return e instanceof Error ? e : new $npm.utils.InternalError(e);
        }
    }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.task" id="apidoc.element.pg-promise.events.task">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>task
        <span class="apidocSignatureSpan">(options, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, context) =&gt; {
    if (typeof options.task === 'function') {
        try {
            options.task(context);
        } catch (e) {
            // silencing the error, to avoid breaking the task;
            $events.unexpected('task', e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Tasks

A task represents a shared connection to be used within a callback function. The callback can be either a regular function or an
 ES6 generator.

A transaction, for example, is just a special type of task, wrapped in `CONNECT-&gt;COMMIT/ROLLBACK`.

```js
db.<span class="apidocCodeKeywordSpan">task</span>(t =&gt; {
// execute a chain of queries;
})
.then(data =&gt; {
    // success;
})
.catch(error =&gt; {
    // failed;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.transact" id="apidoc.element.pg-promise.events.transact">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>transact
        <span class="apidocSignatureSpan">(options, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, context) =&gt; {
    if (typeof options.transact === 'function') {
        try {
            options.transact(context);
        } catch (e) {
            // silencing the error, to avoid breaking the transaction;
            $events.unexpected('transact', e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *     }
 * };
 *
 */
transact: (options, context) =&gt; {
    if (typeof options.transact === 'function') {
        try {
            options.<span class="apidocCodeKeywordSpan">transact</span>(context);
        } catch (e) {
            // silencing the error, to avoid breaking the transaction;
            $events.unexpected('transact', e);
        }
    }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.events.unexpected" id="apidoc.element.pg-promise.events.unexpected">
        function <span class="apidocSignatureSpan">pg-promise.events.</span>unexpected
        <span class="apidocSignatureSpan">(event, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(event, e) =&gt; {
    // If you should ever get here, your app is definitely broken, and you need to fix
    // your event handler to prevent unhandled errors during event notifications.
    //
    // Console output is suppressed when running tests, to avoid polluting test output
    // with error messages that are intentional and of no value to the test.

    /* istanbul ignore if */
    if (!$npm.main.suppressErrors) {
        var stack = e instanceof Error ? e.stack : new Error().stack;
        $npm.con.error('Unexpected error in \'%s\' event handler.\n%s\n', event, stack);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (typeof ctx.options.connect === 'function') {
        try {
            ctx.options.connect(client, ctx.dc, isFresh);
        } catch (e) {
            // have to silence errors here;
            // cannot allow unhandled errors while connecting to the database,
            // as it will break the connection logic;
            $events.<span class="apidocCodeKeywordSpan">unexpected</span>('connect', e);
        }
    }
},

/**
 * @event disconnect
 * @description
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.formatting" id="apidoc.module.pg-promise.formatting">module pg-promise.formatting</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.formatting.formatFunction" id="apidoc.element.pg-promise.formatting.formatFunction">
        function <span class="apidocSignatureSpan">pg-promise.formatting.</span>formatFunction
        <span class="apidocSignatureSpan">(funcName, values, capSQL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function $formatFunction(funcName, values, capSQL) {
    var sql = capSQL ? 'SELECT * FROM ' : 'select * from ';
    return sql + funcName + '(' + formatCSV(values) + ')';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}

if (!error &amp;&amp; (!pgFormatting || isFunc)) {
    try {
        // use 'pg-promise' implementation of values formatting;
        if (isFunc) {
            query = $npm.formatting.<span class="apidocCodeKeywordSpan">formatFunction</span>(query, values, capSQL);
        } else {
            query = $npm.formatting.formatQuery(query, values);
        }
    } catch (e) {
        if (isFunc) {
            var prefix = capSQL ? 'SELECT * FROM' : 'select * from';
            query = prefix + ' ' + query + '(...)';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.formatting.formatQuery" id="apidoc.element.pg-promise.formatting.formatQuery">
        function <span class="apidocSignatureSpan">pg-promise.formatting.</span>formatQuery
        <span class="apidocSignatureSpan">(query, values, raw, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function $formatQuery(query, values, raw, options) {
    if (typeof query !== 'string') {
        throw new TypeError('Parameter \'query\' must be a text string.');
    }
    if (values &amp;&amp; typeof values === 'object') {
        var ctf = values['formatDBType']; // custom type formatting;
        if (typeof ctf === 'function') {
            return $formatQuery(query, resolveFunc(ctf, values), raw || values._rawDBType, options);
        }
        if (values instanceof Array) {
            // $1, $2,... formatting to be applied;
            return formatAs.array(query, values, raw, options);
        }
        if (!(values instanceof Date || values instanceof Buffer)) {
            // $*propName* formatting to be applied;
            return formatAs.object(query, values, raw, options);
        }
    }
    // $1 formatting to be applied, if values != undefined;
    return values === undefined ? query : formatAs.value(query, values, raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!error &amp;&amp; (!pgFormatting || isFunc)) {
try {
    // use 'pg-promise' implementation of values formatting;
    if (isFunc) {
        query = $npm.formatting.formatFunction(query, values, capSQL);
    } else {
        query = $npm.formatting.<span class="apidocCodeKeywordSpan">formatQuery</span>(query, values);
    }
} catch (e) {
    if (isFunc) {
        var prefix = capSQL ? 'SELECT * FROM' : 'select * from';
        query = prefix + ' ' + query + '(...)';
    }
    error = e instanceof Error ? e : new $npm.utils.InternalError(e);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.minify" id="apidoc.module.pg-promise.minify">module pg-promise.minify</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.minify.minify" id="apidoc.element.pg-promise.minify.minify">
        function <span class="apidocSignatureSpan">pg-promise.</span>minify
        <span class="apidocSignatureSpan">(sql, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minify(sql, options) {

    if (typeof sql !== 'string') {
        throw new TypeError("Input SQL must be a text string.");
    }

    if (options !== undefined &amp;&amp; typeof options !== 'object') {
        throw new TypeError("Parameter 'options' must be an object.");
    }

    if (!sql.length) {
        return '';
    }

    var idx = 0, // current index
        result = '', // resulting sql
        len = sql.length, // sql length
        EOL = getEOL(sql), // end-of-line
        space = false, // add a space on the next step
        compress = options &amp;&amp; options.compress; // option 'compress'

    do {
        var s = sql[idx], // current symbol;
            s1 = idx &lt; len - 1 ? sql[idx + 1] : ''; // next symbol;

        if (isGap(s)) {
            while (++idx &lt; len &amp;&amp; isGap(sql[idx]));
            if (idx &lt; len) {
                space = true;
            }
            idx--;
            continue;
        }

        if (s === '-' &amp;&amp; s1 === '-') {
            var lb = sql.indexOf(EOL, idx + 2);
            if (lb &lt; 0) {
                break;
            }
            idx = lb - 1;
            skipGaps();
            continue;
        }

        if (s === '/' &amp;&amp; s1 === '*') {
            var end = sql.indexOf('*/', idx + 2);
            if (end &lt; 0) {
                throwError(PEC.unclosedMLC);
            }
            idx = end + 1;
            skipGaps();
            continue;
        }

        if (s === '"') {
            var closeIdx = sql.indexOf('"', idx + 1);
            if (closeIdx &lt; 0) {
                throwError(PEC.unclosedQI);
            }
            var text = sql.substr(idx, closeIdx - idx + 1);
            if (text.indexOf(EOL) &gt; 0) {
                throwError(PEC.multiLineQI);
            }
            if (compress) {
                space = false;
            }
            addSpace();
            result += text;
            idx = closeIdx;
            skipGaps();
            continue;
        }

        if (s === '\'') {
            var closeIdx = idx;
            do {
                closeIdx = sql.indexOf('\'', closeIdx + 1);
                if (closeIdx &gt; 0) {
                    var step = closeIdx;
                    while (++step &lt; len &amp;&amp; sql[step] === '\'');
                    if ((step - closeIdx) % 2) {
                        closeIdx = step - 1;
                        break;
                    }
                    closeIdx = step === len ? -1 : step;
                }
            } while (closeIdx &gt; 0);
            if (closeIdx &lt; 0) {
                throwError(PEC.unclosedText);
            }
            if (compress) {
                space = false;
            }
            addSpace();
            var text = sql.substr(idx, closeIdx - idx + 1);
            var hasLB = text.indexOf(EOL) &gt; 0;
            if (hasLB) {
                text = text.split(EOL).map(function (m) {
                    return m.replace(/^\s+|\s+$/g, '');
                }).join('\\n');
            }
            var hasTabs = text.indexOf('\t') &gt; 0;
            if (hasLB || hasTabs) {
                var prev = idx ? sql[idx - 1] : '';
                if (prev !== 'E' &amp;&amp; prev !== 'e') {
                    var r = result ? result[result.length - 1] : '';
                    if (r &amp;&amp; r !== ' ' &amp;&amp; compressors.indexOf(r) &lt; 0) {
                        result += ' ';
                    }
                    result += 'E';
                }
                if (hasTabs) {
                    text = text.replace(/\t/g, '\\t');
                }
            }
            result += text;
            idx = closeIdx;
            skipGaps();
            continue;
        }

        if (compress &amp;&amp; compressors.indexOf(s) &gt;= 0) {
            space = false;
            skipGaps();
        }

        addSpace();
        result += s;

    } while (++idx &lt; len);

    return result;

    function skipGaps() {
        if (compress) {
            while (idx &lt; len - 1 &amp;&amp; isGap(sql[id ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.minify.SQLParsingError" id="apidoc.element.pg-promise.minify.SQLParsingError">
        function <span class="apidocSignatureSpan">pg-promise.minify.</span>SQLParsingError
        <span class="apidocSignatureSpan">(code, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SQLParsingError(code, position) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'SQLParsingError';
    this.stack = temp.stack;
    this.code = code; // one of parsingErrorCode values;
    this.error = errorMessages[code].message;
    this.position = position; // Error position in the text: {line, column}
    this.message = "Error parsing SQL at {line:" + position.line + ",col:" + position.column + "}: " + this.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.minify.SQLParsingError" id="apidoc.module.pg-promise.minify.SQLParsingError">module pg-promise.minify.SQLParsingError</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.minify.SQLParsingError.SQLParsingError" id="apidoc.element.pg-promise.minify.SQLParsingError.SQLParsingError">
        function <span class="apidocSignatureSpan">pg-promise.minify.</span>SQLParsingError
        <span class="apidocSignatureSpan">(code, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SQLParsingError(code, position) {
    var temp = Error.apply(this, arguments);
    temp.name = this.name = 'SQLParsingError';
    this.stack = temp.stack;
    this.code = code; // one of parsingErrorCode values;
    this.error = errorMessages[code].message;
    this.position = position; // Error position in the text: {line, column}
    this.message = "Error parsing SQL at {line:" + position.line + ",col:" + position.column + "}: " + this.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.minify.SQLParsingError.prototype" id="apidoc.module.pg-promise.minify.SQLParsingError.prototype">module pg-promise.minify.SQLParsingError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.minify.SQLParsingError.prototype.inspect" id="apidoc.element.pg-promise.minify.SQLParsingError.prototype.inspect">
        function <span class="apidocSignatureSpan">pg-promise.minify.SQLParsingError.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.minify.SQLParsingError.prototype.toString" id="apidoc.element.pg-promise.minify.SQLParsingError.prototype.toString">
        function <span class="apidocSignatureSpan">pg-promise.minify.SQLParsingError.prototype.</span>toString
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (level) {
    level = level &gt; 0 ? parseInt(level) : 0;
    var gap = messageGap(level + 1);
    var lines = [
        'SQLParsingError {',
        gap + 'code: parsingErrorCode.' + errorMessages[this.code].name,
        gap + 'error: "' + this.error + '"',
        gap + 'position: {line: ' + this.position.line + ", col: " + this.position.column + '}',
        messageGap(level) + '}'
    ];
    return lines.join(EOL);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {boolean} [raw=false]
 * Indicates when not to escape the resulting text.
 *
 * @returns {string}
 *
 * - `null` string, if the `value` resolves as `null` or `undefined`
 * - escaped result of `value.<span class="apidocCodeKeywordSpan">toString</span>()`, if the `value` isn't a string
 * - escaped string version, if `value` is a string.
 *
 *  The result is not escaped, if `raw` was passed in as `true`.
 */
text: (value, raw) =&gt; {
    value = resolveFunc(value);
    if (isNull(value)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.special" id="apidoc.module.pg-promise.special">module pg-promise.special</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.special.SpecialQuery" id="apidoc.element.pg-promise.special.SpecialQuery">
        function <span class="apidocSignatureSpan">pg-promise.special.</span>SpecialQuery
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SpecialQuery(type) {
    this.isStream = type === 'stream';
    this.isResult = type === 'result';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.txMode" id="apidoc.module.pg-promise.txMode">module pg-promise.txMode</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.txMode.TransactionMode" id="apidoc.element.pg-promise.txMode.TransactionMode">
        function <span class="apidocSignatureSpan">pg-promise.txMode.</span>TransactionMode
        <span class="apidocSignatureSpan">(tiLevel, readOnly, deferrable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TransactionMode(tiLevel, readOnly, deferrable) {

    if (!(this instanceof TransactionMode)) {
        return new TransactionMode(tiLevel, readOnly, deferrable);
    }

    if (tiLevel &amp;&amp; typeof tiLevel === 'object') {
        readOnly = tiLevel.readOnly;
        deferrable = tiLevel.deferrable;
        tiLevel = tiLevel.tiLevel;
    }

    var level, accessMode, deferrableMode, capBegin, begin = 'begin';

    tiLevel = (tiLevel &gt; 0) ? parseInt(tiLevel) : 0;

    if (tiLevel &gt; 0 &amp;&amp; tiLevel &lt; 4) {
        var values = ['serializable', 'repeatable read', 'read committed'];
        level = 'isolation level ' + values[tiLevel - 1];
    }

    if (readOnly) {
        accessMode = 'read only';
    } else {
        if (readOnly !== undefined) {
            accessMode = 'read write';
        }
    }

    // From the official documentation: http://www.postgresql.org/docs/9.5/static/sql-set-transaction.html
    // The DEFERRABLE transaction property has no effect unless the transaction is also SERIALIZABLE and READ ONLY
    if (tiLevel === isolationLevel.serializable &amp;&amp; readOnly) {
        if (deferrable) {
            deferrableMode = 'deferrable';
        } else {
            if (deferrable !== undefined) {
                deferrableMode = 'not deferrable';
            }
        }
    }

    if (level) {
        begin += ' ' + level;
    }

    if (accessMode) {
        begin += ' ' + accessMode;
    }

    if (deferrableMode) {
        begin += ' ' + deferrableMode;
    }

    capBegin = begin.toUpperCase();

    this.begin = cap =&gt; {
        return cap ? capBegin : begin;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pg-promise.utils" id="apidoc.module.pg-promise.utils">module pg-promise.utils</a></h1>


    <h2>
        <a href="#apidoc.element.pg-promise.utils.buildSqlModule" id="apidoc.element.pg-promise.utils.buildSqlModule">
        function <span class="apidocSignatureSpan">pg-promise.utils.</span>buildSqlModule
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildSqlModule(config) {

    if ($npm.utils.isText(config)) {
        var path = $npm.utils.isPathAbsolute(config) ? config : $npm.path.join($npm.utils.startDir, config);
        config = require(path);
    } else {
        if ($npm.utils.isNull(config)) {
            var defConfig = $npm.path.join($npm.utils.startDir, 'sql-config.json');
            // istanbul ignore else;
            if (!$npm.fs.existsSync(defConfig)) {
                throw new Error('Default SQL configuration file not found: ' + defConfig);
            }
            // cannot test this automatically, because it requires that file 'sql-config.json'
            // resides within the Jasmine folder, since it is the client during the test.
            // istanbul ignore next;
            config = require(defConfig);
        } else {
            if (!config || typeof config !== 'object') {
                throw new TypeError('Invalid parameter \'config\' specified.');
            }
        }
    }

    if (!$npm.utils.isText(config.dir)) {
        throw new Error('Property \'dir\' must be a non-empty string.');
    }

    var total = 0;

    var tree = enumSql(config.dir, {recursive: config.recursive, ignoreErrors: config.ignoreErrors}, () =&gt; {
        total++;
    });

    var modulePath = './loadSql', moduleName = 'load';
    if (config.module &amp;&amp; typeof config.module === 'object') {
        if ($npm.utils.isText(config.module.path)) {
            modulePath = config.module.path;
        }
        if ($npm.utils.isText(config.module.name)) {
            moduleName = config.module.name;
        }
    }

    var d = new Date();

    var header =
        '/////////////////////////////////////////////////////////////////////////' + EOL +
        '// This file was automatically generated by pg-promise v.' + $npm.package.version + EOL +
        '//' + EOL +
        '// Generated on: ' + d.toLocaleDateString() + ', at ' + d.toLocaleTimeString() + EOL +
        '// Total files: ' + total + EOL +
        '//' + EOL +
        '// API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule' + EOL +
        '/////////////////////////////////////////////////////////////////////////' + EOL + EOL +
        '\'use strict\';' + EOL + EOL +
        'var ' + moduleName + ' = require(\'' + modulePath + '\');' + EOL + EOL +
        'module.exports = ';

    var code = header + objectToCode(tree, value =&gt; {
            return moduleName + '(' + JSON.stringify(value) + ')';
        }) + ';';

    if ($npm.utils.isText(config.output)) {
        var p = config.output;
        if (!$npm.utils.isPathAbsolute(p)) {
            p = $npm.path.join($npm.utils.startDir, p);
        }
        $npm.fs.writeFileSync(p, code);
    }

    return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.utils.camelize" id="apidoc.element.pg-promise.utils.camelize">
        function <span class="apidocSignatureSpan">pg-promise.utils.</span>camelize
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function camelize(text) {
    text = text.replace(/[\-_\s\.]+(.)?/g, (match, chr) =&gt; {
        return chr ? chr.toUpperCase() : '';
    });
    return text.substr(0, 1).toLowerCase() + text.substr(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         camelizeColumns(data);
*     }
* };
*
* function camelizeColumns(data) {
*     var template = data[0];
*     for (var prop in template) {
*         var camel = pgp.utils.<span class="apidocCodeKeywordSpan">camelize</span>(prop);
*         if (!(camel in template)) {
*             for (var i = 0; i &lt; data.length; i++) {
*                 var d = data[i];
*                 d[camel] = d[prop];
*                 delete d[prop];
*             }
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.utils.camelizeVar" id="apidoc.element.pg-promise.utils.camelizeVar">
        function <span class="apidocSignatureSpan">pg-promise.utils.</span>camelizeVar
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function camelizeVar(text) {
    text = text.replace(/[^a-zA-Z0-9\$_\-\s\.]/g, '').replace(/^[0-9_\-\s\.]+/, '');
    return camelize(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.utils.enumSql" id="apidoc.element.pg-promise.utils.enumSql">
        function <span class="apidocSignatureSpan">pg-promise.utils.</span>enumSql
        <span class="apidocSignatureSpan">(dir, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enumSql(dir, options, cb) {
    if (!$npm.utils.isText(dir)) {
        throw new TypeError('Parameter \'dir\' must be a non-empty text string.');
    }
    if (!options || typeof options !== 'object') {
        options = {};
    }
    cb = (typeof cb === 'function') ? cb : null;
    return _enumSql(dir, options, cb, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pg-promise.utils.objectToCode" id="apidoc.element.pg-promise.utils.objectToCode">
        function <span class="apidocSignatureSpan">pg-promise.utils.</span>objectToCode
        <span class="apidocSignatureSpan">(obj, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function objectToCode(obj, cb) {

    if (!obj || typeof obj !== 'object') {
        throw new TypeError('Parameter \'obj\' must be a non-null object.');
    }

    cb = (typeof cb === 'function') ? cb : null;

    return '{' + generate(obj, 1) + EOL + '}';

    function generate(obj, level) {
        var code = '', gap = $npm.utils.messageGap(level);
        var idx = 0;
        for (var prop in obj) {
            var value = obj[prop];
            if (idx) {
                code += ',';
            }
            if (value &amp;&amp; typeof value === 'object') {
                code += EOL + gap + prop + ': {';
                code += generate(value, level + 1);
                code += EOL + gap + '}';
            } else {
                code += EOL + gap + prop + ': ';
                if (cb) {
                    code += cb(value, prop, obj);
                } else {
                    code += JSON.stringify(value);
                }
            }
            idx++;
        }
        return code;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>